# -*- coding: utf-8 -*-
"""Assignment Solution - NumPy Operations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1__4R_tMX-hU51zEh8xaNQoGTS2tOJO1M

# <u> Use only those concepts which have been taught till now </u>
"""

import numpy as np

"""# <u>**Problem 1**</u>

### What is the average value of the first 5 rows of the third and fourth columns?


"""

np.random.seed(21) # This guarantees the code will generate the same set of random numbers whenever executed
random_integers = np.random.randint(1,high=500000, size=(20, 5))
random_integers

# Your code here
random_integers[:5,2:4].mean()

"""#<u>**Problem 2**</u>

### In this problem, we are going to calculate distances between some pairs of points :

### <u> Measures of distances </u>
* ### Euclidean Distance : The distance between two points $(x_{1},y_{1})$ , $(x_{2},y_{2})$ is defined as :
${\displaystyle d(x,y)={\sqrt {(x_{1}-x_{2})^{2}+(y_{1}-y_{2})^{2}}}.}$

* ### Manhattan Distance : The distance between two points $(x_{1},y_{1})$ , $(x_{2},y_{2})$ is defined as :
${\displaystyle d(x,y)=|x_{1}-x_{2}|+|y_{1}-y_{2}|}$

### Create a 2-D array of 10 points where the x-coordinates and the y-coordinates can take random integral values between 5 and 20.


### Next, create two 1-D arrays(one for  Euclidean distance and the other for  Manhattan distance) for these points
"""

# Create the 10 points
points=np.random.randint(5,20,size=(10,2))
points

# Calculate Euclidean distances between these pairs of points (total 10*10 = 100 pairs including self pairs). This should give you a 10*10 2-D array where each value corresponds to the distance between a pair

def eucledian_distance(point1,point2):
    """Calculates and returns Eucledian Distance"""
    x1,y1=point1
    x2,y2=point2
    return round(((x2-x1)**2+(y2-y1)**2)**0.5,2)                                # calculating eucledian distance

euclidean_distances=[]
for i in range(10):
    inner_llist=[]
    for j in range(10):
        inner_llist.append(eucledian_distance(points[i],points[j]))
    euclidean_distances.append(np.asarray(inner_llist))
euclidean_distances = np.asarray(euclidean_distances)
print(euclidean_distances)

# Calculate Manhattan distances between these pairs of points (total 10*10 = 100 pairs inlcuding self pairs).This should give you a 10*10 2-D array where each value corresponds to the distance between a pair.

def manhattan_distance(point1,point2):
    """Calclates and returns Manhattan Distance"""
    x1,y1=point1
    x2,y2=point2
    return round((abs(x2-x1)+abs(y2-y1)),2)                                     # The manhattan distance

manhattan_distances=[]
for i in range(10):
    inner_llist=[]
    for j in range(10):
        inner_llist.append(manhattan_distance(points[i],points[j]))
    manhattan_distances.append(np.asarray(inner_llist))
manhattan_distances=np.asarray(manhattan_distances)
print(manhattan_distances)

"""## Find the closest pairs (excluding self pairs) on the basis of both the distance measures"""

# Your code here

nearest_points_manhattan=[]
for ind,arr in enumerate(manhattan_distances+np.identity(10)*1000):
    nearest_points_manhattan.append((points[ind],points[arr.argmin()]))         # index of the value with min distance is stored and the corrosponding points accesed

print(nearest_points_manhattan)

nearest_points_euclidean=[]
for ind,arr in enumerate(euclidean_distances+np.identity(10)*1000):
    nearest_points_euclidean.append((points[ind],points[arr.argmin()]))         # index of the value with min distance is stored and the corrosponding points accesed

print(nearest_points_euclidean)

"""# <u>**Problem 3**</u>

## Extract all the contiguous 3x3 blocks from a random 10x10 matrix. For example, the first matrix corresponds to [:3,:3], then the second matrix corresponds to [:3,1:4],.... Once you have covered the first three rows, then the next set of matrices would be [1:4,:3],[1:4,1:4],.... and so on and so forth. The last matrix would be [7:10,7:10]
"""

# Your code below ..

contiguous_list=[]
big_matrix=np.random.randint(1,100,size=(10,10))
print(big_matrix)
for row in range(0,8):      # for accessing rows one by one
    for col in range(0,8):  # for accessing rows one by one
        contiguous_list.append(big_matrix[row:row+3,col:col+3])

contiguous_array=np.asarray(contiguous_list)

print(contiguous_array)

"""#<u>**Problem 4**</u>

### Write a function which finds the nearest value from a given value in an array of random N elements. Suppose you created an 1-D array with 15 elements taking values between 10 and 500. Your function would take any input from these values and return the nearest value. (You can use np.abs() function)
"""

# Your function below

def get_nearest_value(elem,array):
    """Return the nearest value in the given array for given input"""
    nearest_value = array.flat[np.abs(array - elem).argmin()]                   # flatern and then findind the value with min difrence for given input
    return nearest_value
array=np.random.randint(10,500, size=(1, 15))
print(array)

ele=int(input("Enter the element for which you want to find the nearest value for "))
print(f"Nearest point to {ele} is {get_nearest_value(ele,array)}")

